{{#features}}
	<li id="{{feature_ol_uid}}" class="inventaire item" style="height: 300px;">
        <p>
            <b>Feature ol uid : </b> {{feature_ol_uid}}
        </p>
        
        {{#observations}}
            <p>
                <b>Streams sélectionnés : </b> {{streamsNames}}
            </p>
        {{/observations}}
        <div class="chart-container" style="position: relative; margin: auto; height: 250px; width:80vh">
            <canvas id="chart"></canvas>
        </div>
    </li>
    <script>

    function getRandomColor() {
        var letters = '0123456789ABCDEF'.split('');
        var color = '#';
        for (var i = 0; i < 6; i++ ) {
            color += letters[Math.round(Math.random() * 15)];
        }
        return color;
    }

    const mvLayer = "lora";
    const sensorthingsData = mviewer.sensorthings[mvLayer];
    let featureWithObservations = mviewer.getLayer(mvLayer).layer.getSource().getFeatures().filter(x => x.ol_uid === sensorthingsData.featureIdSelected);
    const props = featureWithObservations[0].getProperties();
    
    const streamsObs = sensorthingsData.selected.map(x => parseInt(x));
    let streamsId = streamsObs[0];
    const firstDatastreamObservation = props.observations[streamsId].result;
    let datesValues = firstDatastreamObservation.map(o => new Date(o.resultTime).toLocaleDateString());
    let datasets = [];
    // DATASTREAM
    if(sensorthingsData.datastreams && sensorthingsData.datastreams.length) {
        datastreamDataset = streamsObs.map(data => {
            if(!data && !props.observations[data]?.result) return;
            let observations = props.observations[data].result;
            let yValues = observations.map(o => o.result);
            let randomColor = getRandomColor();
            const streams = sensorthingsData.datastreams;
            return {
                label: streams.filter(x => x.id === data)[0]?.name,
                data: yValues,
                borderWidth: 1.5,
                borderColor: randomColor,
                backgroundColor: randomColor,
                fill: false
            }
        });
        datasets = [...datasets, ...datastreamDataset];
    }
    // MULTIDATASTREAM
    if(sensorthingsData.multidatastreams && sensorthingsData.multidatastreams.length) {
        streamsObs.map(data => {
            let observations = props.observations[data].result;
            let yValues = observations.map(o => o.result);
            const streams = sensorthingsData.multidatastreams;
            let unitOfMeasures = sensorthingsData.multidatastreams[0].unitOfMeasurements.map(x => x.name);
            let unitOfMeasurementsDataset = unitOfMeasures.map(unit => {
                let randomColor = getRandomColor();
                return {
                    data: observations.map(o => o.result[unit]),
                    label: unit,
                    borderWidth: 1.5,
                    borderColor: randomColor,
                    backgroundColor: randomColor,
                    fill: false
                }
            });
            datasets = [...datasets, ... unitOfMeasurementsDataset]
        })
        
    }

    var config = {
        type: 'line',
        data: {
            labels: datesValues,
            datasets: datasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false
        }
    }
    var ctx = document.getElementById('chart').getContext('2d');
    new Chart(ctx, config);
    </script>
{{/features}}